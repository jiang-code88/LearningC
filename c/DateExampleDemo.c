#include<stdio.h>

// a,b,c这三个变量都属于文件作用域，作用域为延伸到源文件的结束。
// a ——属于文件作用域的声明，缺省情况下的链接属性为external。
// 定义 a 和 b 的其他源文件在使用这两个变量时实际所访问的是声明于此的这两个变量。
int a = 5;
// 如果变量 b 的定义在非该源文件的其他地方，关键字 extern 是非必需的。
// 因为它的缺省链接属性就是external。
extern int b;
// static关键字修改了 变量c缺省的external链接属性 为 internal。
// 即 变量c 只能在该源文件中被访问到。
// static 关键字只能用于属于 external 链接属性的声明上。
static int c;
// a,b,c三个变量的存储类型是静态。
// 这些变量将在程序执行之前创建，并一直保持它们的值（如果没有赋值更改），直到程序结束。

// 函数 d 的缺省链接类型是external，只有其他源文件在文件上存在该函数 d 的原型，就可以调用 d。
// 如果将函数声明为 static ，链接属性就修改为 internal，其他源文件将不可以访问到该函数。
// 形参 e 的存储类型为自动存储类型，不具有链接属性，只能在函数内部通过名字访问。
int d ( int e)
{
    // 变量 f 的存储类型为 自动存储类型（缺省），每次函数被调用时初始值赋值 15。
    int f = 15;
    // 隐藏同名的静态变量 b，变量 b 的存储类型是寄存器类型，初始值是垃圾。
    register int b;
    // 变量 g 的存储类型是 静态，程序的整个执行过程中一直存在。
    // 当程序开始执行时，他被初始化为 20，当该函数每次调用时，将不会被重新初始化。
    static int g = 20;
    // 以上声明了三个局部变量，只能在函数中被访问，作用域是到函数结束为止。
    // 局部变量不具有链接属性，不能在函数的外部通过名字访问。

    // 其实这个声明就是引用访问到第六行，程序刚开始声明的静态变量 a。
    // 但是这里的声明并不需要，因为声明这个变量的代码块在第六行声明的作用域内，可以直接访问到第六行声明的静态变量 a。
    extern int a;
    //...
    {
        // 变量 e 和 a 是该代码块的局部变量，作用域仅限声明其的代码块，不具有链接属性，具有自动存储类型。
        int e;
        // 隐藏同名的静态变量 a
        int a;
        // 如果不加 extern 变量 h 将会是一个局部变量，局部变量是不具备链接属性的。
        // 添加 extern 使得这个代码块可以访问到其他源文件定义的全局变量 h（属于静态变量）。
        extern int h;
        //...
    }
    //...
    {
        // 声明了局部变量 x 和 e（自动存储类型，无链接属性，作用域仅限该代码块）
        int x;
        // 该代码块中声明的变量 e 和上一个代码块声明的变量 e 是不同变量。
        int e;
        //...
    }
    //...
}

// 函数 i 的链接类型被修改为 静态链接类型（internal），可以防止它被这个源文件之外的任何函数调用。
// 函数 d 是无法调用函数 i 的，因为在函数 d 之前不存在函数 i 的原型。也就是函数 i 没有定义在函数 d 之前。
static int i()
{
    //...
}

int function(void){
	while(3>1){
		while(3>1){
			while(3>1)
				return;
		}
	}
}

int main( void )
{
    /* code */
    return 0;
}
