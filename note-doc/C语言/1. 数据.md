## 数据

### 基本数据类型

- 整数

  - char字符：0-127

    - signed char 有符号：-127 - 127

    - unsigned char 无符号：0 - 255

  - short int 短整型（默认有符号）：-32767 - 32767

    - unsigned short int 无符号：0- 65535
    - 至少 16 位

  - int 整数（默认有符号）：-32767 - 32767

    - unsigned int 无符号：0 - 65535

  - long int 长整型（默认有符号）：-2147483647 - 2147483647

    - unsigned long 无符号：0 - 4294967295
    - 至少 32 位

  - 整数字面值（常量）

    - 当出现整数字面值时，如何确定属于上述的那种数据类型：
      - 整数字面值末尾添加 L 或 l 将使这个整数解释为 long int 类型。
      - 整数字面值末尾添加 U 或 u 将使这个数值指定为 unsiged 整数值。
    - 十进制整数字面值可能是 int、long、或者 unsigned long，缺省情况下它是最短类型但能容纳这个值的类型。
    - 整数也可以使用八进制表示：数值前面以 0 开头。
    - 整数也可以使用十六进制表示：数值前面以 0x 开头。
    - 字符常量：他们的类型总是 int 。使用单引号包围起来的单个字符或字符转义序列或三字母词。

  - 枚举类型（enumerated）

    ```c
    // 声明枚举类型 枚举类型名为 Jar_Type
    enum Jar_Type { CPU,PINT,QUART,HALF_GALLON,GALLON};
    // 声明该枚举类型的变量
    enum Jar_Type milk_jug, gas_can, medicine_bottle;
    // 简化声明
    enum Jar_Type { CPU,PINT,QUART,HALF_GALLON,GALLON}milk_jug, gas_can, medicine_bottle;
    // 这种类型的变量实际上是以整数的形式存储，这里符号名的实际值都是整数值，CPU 是 0，PINT 是 1，以此类推，逐个增大 1。
    // 同时可以为符号名指定特定的整数值，如果只对部分的符号名使用整数值进行赋值是合法的，未显式指定的符号名的值，将是比它前面一个符号名的值大 1。
    enum Jar_Type { CPU = 8, PINT = 16, QUART = 32, HALF_GALLON = 64, GALLON = 128};
    
    ```

- 浮点数

  - float
    - 单精度
  - double
    - 双精度
  - long double
    - 拓展精度
  - 浮点数字面值（常量）
    - 十进制的形式，必须有一个小数点或一个指数。
    - 缺省情况下都是double类型，如果后面跟一个 L 或 l 表示它是一个 long double 类型，如果末尾跟一个 F 或 f 表示它是一个 float 类型。

- 指针

  - 变量存储在计算机的内存中，每个变量都占据一个特定的位置，每个内存位置都由<u>地址</u>唯一确定并引用。指针变量是一个其值为另外一个内存地址的变量。

  - C语言提供操作符，实现获得一个变量的地址存储于指针变量中以及通过一个指针变量取得它所指向的值或数据结构。

  - 字符串常量

    - 字符串：一串以'\0'结尾的零个或多个字符，通常存储在字符数组中。

    - 字符串常量的直接值是一个指针（组成字符串的这些字符所存储的地址），而不是字符串中的这些字符本身。

    - 可以把字符串常量赋值给一个 指向字符的指针，而不能把字符串赋值给一个字符数组。

      ```c
      // 字符串常量 "hello world" 中第一个字符的地址对该字符指针初始化赋值。
      char* message = "Hello world";
      ```

### 基本声明

```
说明符（一个或多个） 声明表达式列表（标识符列表）
```

#### 说明符

- 用于描述被声明的标识符的基本类型。
  - 修改变量的长度：short、long。
  - 修改是否有符号：signed、unsigned。
- 用于改变标识符的缺省存储类型和作用域。

#### 声明简单数组

```c
int values[20];
```

#### 声明指针

```c
// 声明指向 int 类型的指针
int *a;
// 这个声明和上一个声明具有相同的意思
int* a;
// 声明三个指向 int 类型的指针
int *a,*b,*c;
// 声明一个执行 int 类型指针和两个整形变量
int* a,b,c;
```

#### typedef 简化复杂声明

- 使用 typedef 声明类型可以减少使声明变得又臭又长的危险。

```c
// 把变量 ptr_to_char 声明为指向字符的指针。
typedef char *ptr_to_char;
// 声明 a 是指向字符的指针。
ptr_to_char a;
```

#### 常量

```c
// 将 a 声明为一个整数
int const a;
const int a;
```

关于指针的常量

```c
// 指向整型的指针
int *pi;
// 指向整型常量的指针——可以修改指针的值，不可以修改指针所指向的值。
int const *pci;
// 指向整型的常量指针——不可以修改指针的值，可以修改指针所指向的值。
int *const cpi;
// 指针本身和指针所指向的值都是常量不可修改。 
int const *const cpci;
// 使用 #define 比使用 const 变量更好，例如下面的常量定义只允许使用 #define 写
#define MAX_ELEMENT 50
int arrays[MAX_ELEMENT];
```

### 作用域

- 当变量在程序的某个部分被声明时，他只有在程序的一定区域才能被访问。这个区域由标识符的作用域决定。标识符的作用域就是程序中该标识符可以被使用的区域。
- 标识符的作用域由标识符声明的位置决定。

#### 代码块作用域：

- 一对花括号之间的所有语句（代码块）中声明的标识符可以被这代码块中所有的语句访问。代码块中声明的标识符的作用域就是从代码快开始到代码块尾部。
- 当代码块处于嵌套状态时，内层代码块的标识符作用域就是到达声明其的代码块的尾部便中止。内层与外层的标识符如果同名，外层的那个标识符将无法在内层代码块中通过名字访问到，只能通过名字访问到内层代码块中声明的标识符。

#### 文件作用域：

- 在代码块之外声明的标识符（变量名、常量名、函数名）都具有文件文件作用域，表示这些标识符从它们声明的地方直到它所在的源文件末尾都是可以访问的。

### 链接属性

- 不同文件中出现的相同标识符如何处理。
- 缺省情况下，变量和函数声明的链接属性是 external 。

#### external 外部（共享）

- 标识符不论声明多少次、位于几个源文件都表示同一个实体。

#### internal 内部（私有）

- 在同一个源文件内的所有声明中都指向同一个实体。

#### none 无（独立）

- 同名标识符的多个声明被当作独立不同的实体。

#### 修改标识符的链接属性

- extern：为一个标识符声明指定 external 链接属性，使得这里的这个声明可以链接访问到在其他任何位置定义的这个实体。
  - 如果有一个属于文件作用域的声明变量，你在另外一个源文件中使用这个变量是完全可以，另外的源文件声明中添加extern只是为了更容易理解这个意图。
- static：某个声明在正常情况下具有 external 链接属性，加上 static 可以使得它的链接属性变成 internal。视为该声明是该源文件私有的，其他源文件声明的将访问的是另一个不同的变量，其他源文件不可以调用该函数，只能在声明它们的源文件中访问。
- 当第一次使用上面的关键字声明指定了标识符的链接属性后，第二次使用于该标识符或者以后的其他声明指定时，并不会修改它第一次指定的链接属性。

### 存储类型

- 存储变量值的内存类型—变量何时被创建、何时销毁和其值可以保持多久。
- 变量可以被存储的位置：普通内存、运行时堆栈和硬件寄存器，三个地方存储的变量有不同的特性。

代码块之外声明的变量（缺省）

- 存储于静态内存中，称为静态变量，其是无法再指定其他存储类型的。
- 在程序运行之前创建，在程序的整个执行期间始终存在。并保持原先的值，除非给它赋一个新值或者程序结束。
- 如果不显式的指定静态变量的初始值，静态变量将初始化为 0。

代码块内部声明的变量（缺省）

- 存储类型是自动类型也就是存储于运行时堆栈中。目的在于需要时才进行分配，节省内存总需求量，同时在堆栈上为它们分配存储可以有效地实现递归。
- 当程序执行到声明自动变量的代码块时，自动变量才被创建，当程序的执行流离开该代码块时（代码块执行完毕后），这些自动变量便自行销毁。
- 除非你对自动变量进行显式的初始化，否则当自动变量被创建时，它们的值总是垃圾。

代码块内部声明的变量（添加static关键字）

- 可以将代码块内部声明的变量的存储类型从自动类型转化为静态类型，也就是存储于静态内存中，属于静态变量。
- 修改的存储类型的目的在于让变量的值在函数的多次调用中，始终保持原先的值。

代码块内存声明的变量（添加register关键字）

- 提示编译器创建变量时将变量存储于机器的硬件寄存器中而不是内存（运行时堆栈也是存储于内存中）中，这类存储的变量称为寄存器变量。
- 寄存器变量相比于存储于内存和运行时堆栈的变量访问效率高。
- 但是编译器并并一定要理睬需要使用硬件寄存器存储的变量（添加regist关键字的变量），当太多的变量被使用 register 关键字声明时，它只会选取其中的前几个存储在硬件寄存器中，其余的按普通自动变量的存储方式进行存储。

